using System;
using System.Collections.Generic;
using System.IO;
using Dexih.Utils.CopyProperties;
using Microsoft.ML;
using Microsoft.ML.Data;
using Microsoft.ML.Trainers;

namespace dexih.functions.ml
{
    public class RecommendationAnalysis
    {
        private List<RecommendationEntry> _recommendationEntries;
        private PredictionEngine<RecommendationEntry, RecommendationPrediction> _predictionEngine;


        public class RecommendationPrediction
        {
            public float Score { get; set; }
        }

        public class RecommendationEntry
        {
            public Single Label { get; set; }
            public string Item1 { get; set; }

            public string Item2 { get; set; }
        }
        
        public void Reset()
        {
            _recommendationEntries = null;
            _predictionEngine = null;
        }

        [TransformFunction(FunctionType = EFunctionType.Aggregate, Category = "Machine Learning", Name = "Recommendation Analysis - Train", Description = "Builds a recommendation model using matrix factorization based on the training data.", ResultMethod = nameof(RecommendationTrainResult), ResetMethod = nameof(Reset))]
        public void RecommendationTrain(
            [TransformFunctionParameter(Description = "First item of a known pair." )]string item1, 
            [TransformFunctionParameter(Description = "Second item of a known pair." )]string item2)
        {
            if (_recommendationEntries == null)
            {
                _recommendationEntries = new List<RecommendationEntry>();
            }
            _recommendationEntries.Add(new RecommendationEntry() {Item1 = item1, Item2 = item2});
        }
        
        [TransformFunctionParameter(Name = "Model", Description = "The model generated by the recommendation engine." )]
        public byte[] RecommendationTrainResult(
            [TransformFunctionParameter(Description = "Loss function minimized for finding factor matrices." )] MatrixFactorizationTrainer.LossFunctionType lossFunction = MatrixFactorizationTrainer.LossFunctionType.SquareLossRegression, 
            [TransformFunctionParameter(Description = "Importance of unobserved entries' loss in one-class matrix factorization. Applicable if LossFunction set to SquareLossOneClass", ListOfValues = new []{"1", "0.01", "0.001", "0.0001"})] float alpha = 9.99999974737875E-05f,
            [TransformFunctionParameter(Description = "Rank of approximation matrices.", ListOfValues = new []{"8", "16", "64", "128"})] float approximationRank = 8,
            [TransformFunctionParameter(Description = "Desired negative entries value in one-class matrix factorization. Applicable if LossFunction set to SquareLossOneClass", ListOfValues = new []{"0.000001", "0", "0.1", "0.01"})] float c = 9.99999997475243E-07f,
            [TransformFunctionParameter(Description = "Regularization parameter.", ListOfValues = new []{"0.01","0.05","0.1","0.5","1"})] float lambda = 0.1f,
            [TransformFunctionParameter(Description = "Initial learning rate. It specifies the speed of the training algorithm.")] float leaningRate = 0.1f,
            [TransformFunctionParameter(Description = "Force the factor matrices to be non-negative.")] bool nonNegative = false,
            [TransformFunctionParameter(Description = "Number of training iterations.", ListOfValues = new []{"10", "20", "40"})] int numberOfIterations = 20
            )
        {
            // Create a new context for ML.NET operations. It can be used for exception tracking and logging,
            // as a catalog of available operations and as the source of randomness.
            var mlContext = new MLContext();
            var trainData = mlContext.Data.LoadFromEnumerable(_recommendationEntries);

            MatrixFactorizationTrainer.Options options = new MatrixFactorizationTrainer.Options();
            options.MatrixColumnIndexColumnName = "Item1Key";
            options.MatrixRowIndexColumnName = "Item2Key";
            options.LabelColumnName= "Label";

            options.Alpha = alpha;
            options.C = c;
            options.Lambda = lambda;
            options.LearningRate = leaningRate;
            options.LossFunction = lossFunction;
            options.NonNegative = nonNegative;
            options.NumberOfIterations = numberOfIterations;
            options.Quiet = true;
            
            var pipeline = mlContext.Transforms
                .Conversion.MapValueToKey("Item1Key", "Item1")
                .Append(mlContext.Transforms.Conversion.MapValueToKey("Item2Key", "Item2"), TransformerScope.TrainTest)
                .Append(mlContext.Recommendation().Trainers.MatrixFactorization(options));

            var trainedModel= pipeline.Fit(trainData);
            return Helpers.SaveModel(mlContext, trainData.Schema, trainedModel);
        }
        
        [TransformFunction(FunctionType = EFunctionType.Aggregate, Category = "Machine Learning", Name = "Recommendation Analysis - Evaluate", Description = "Evaluates the prediction accuracy of recommendation analysis model based on the training data.", ResultMethod = nameof(RecommendationEvaluateResult), ResetMethod = nameof(Reset))]
        public void RecommendationEvaluate(
            [TransformFunctionParameter(Description = "First item of a known pair." )]string item1, 
            [TransformFunctionParameter(Description = "Second item of a known pair." )]string item2)
        {
            if (_recommendationEntries == null)
            {
                _recommendationEntries = new List<RecommendationEntry>();
            }
            _recommendationEntries.Add(new RecommendationEntry() {Item1 = item1, Item2 = item2});
        }
        
        public RegressionMetrics RecommendationEvaluateResult(byte[] sentimentModel)
        {
            // Create a new context for ML.NET operations. It can be used for exception tracking and logging,
            // as a catalog of available operations and as the source of randomness.
            var mlContext = new MLContext();

            // load the sentiment model
            var stream = new MemoryStream( sentimentModel );
            var trainedModel = mlContext.Model.Load(stream, out var inputSchema);

            // Turn the data into the ML.NET data view.
            var trainData = mlContext.Data.LoadFromEnumerable(_recommendationEntries);

            // run the evaluation
            var predictions = trainedModel.Transform(trainData);
            var metrics = mlContext.Recommendation().Evaluate(predictions);

            return metrics.CloneProperties<RegressionMetrics>();
        }
        
        [TransformFunction(FunctionType = EFunctionType.Map, Category = "Machine Learning", Name = "Recommendation Analysis - Predict", Description = "Recommends a recommendation score using matrix factorization based on the training data.", ResetMethod = nameof(Reset))]
        [TransformFunctionParameter(Name = "Score", Description = "The recommendation score based on the pair." )]
        public float RecommendationPredict(
            [TransformFunctionParameter(Name = "Model", Description = "The model generated by the recommendation training function." )] byte[] model, 
            [TransformFunctionParameter(Description = "First item of a known pair." )]string item1, 
            [TransformFunctionParameter(Description = "Second item of a known pair." )]string item2)
        {
            if (_predictionEngine == null)
            {
                var mlContext = new MLContext();
                var trainingModel = Helpers.LoadModel(mlContext, model, out _);
                _predictionEngine = mlContext.Model.CreatePredictionEngine<RecommendationEntry, RecommendationPrediction>(trainingModel);
            }

            var recommendationPrediction = _predictionEngine.Predict(new RecommendationEntry() {Item1 = item1, Item2 = item2});
            return recommendationPrediction.Score;
        }
    }
}